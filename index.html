<!DOCTYPE html>
<html lang="en">
    <head>

    </head>
    <body>
        <div id="container"></div>
        <script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>
        <script type="module">

            import * as THREE from 'three';
            import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
            import { VRButton } from 'three/addons/webxr/VRButton.js';
            import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
		    import { OculusHandModel } from 'three/addons/webxr/OculusHandModel.js';
		    import { createText } from 'three/addons/webxr/Text2D.js';
    		import { World, System, Component, TagComponent, Types } from 'three/addons/libs/ecsy.module.js';

            class Object3D extends Component { }
        	Object3D.schema = {
			    object: { type: Types.Ref }
		    };

		    class Button extends Component { }
    		Button.schema = {
			    // button states: [resting, pressed, fully_pressed, recovering]
			    currState: { type: Types.String, default: 'resting' },
			    prevState: { type: Types.String, default: 'resting' },
			    pressSound: { type: Types.Ref, default: null },
			    releaseSound: { type: Types.Ref, default: null },
			    restingY: { type: Types.Number, default: null },
			    surfaceY: { type: Types.Number, default: null },
			    recoverySpeed: { type: Types.Number, default: 0.4 },
			    fullPressDistance: { type: Types.Number, default: null },
			    action: { type: Types.Ref, default: () => { } }
		    };

		    class ButtonSystem extends System {
			    init( attributes ) {
				    this.renderer = attributes.renderer;
				    this.soundAdded = false;
    			}
    			execute( /*delta, time*/ ) {
    				let buttonPressSound, buttonReleaseSound;
				    if ( this.renderer.xr.getSession() && ! this.soundAdded ) {
					    const xrCamera = this.renderer.xr.getCamera();
    					const listener = new THREE.AudioListener();
	    				xrCamera.add( listener );

		    			// create a global audio sourcep
			    		buttonPressSound = new THREE.Audio( listener );
				    	buttonReleaseSound = new THREE.Audio( listener );

					    // load a sound and set it as the Audio object's buffer
					    const audioLoader = new THREE.AudioLoader();
					    audioLoader.load( 'sounds/button-press.ogg', function ( buffer ) {
    						buttonPressSound.setBuffer( buffer );
					    } );
					    audioLoader.load( 'sounds/button-release.ogg', function ( buffer ) {
    						buttonReleaseSound.setBuffer( buffer );
    					} );
					    this.soundAdded = true;
    				}

				    this.queries.buttons.results.forEach( entity => {
    					const button = entity.getMutableComponent( Button );
					    const buttonMesh = entity.getComponent( Object3D ).object;
					    // populate restingY
					    if ( button.restingY == null ) {
    						button.restingY = buttonMesh.position.y;
    					}
    					if ( buttonPressSound ) {
    						button.pressSound = buttonPressSound;
    					}
    					if ( buttonReleaseSound ) {
    						button.releaseSound = buttonReleaseSound;
    					}
    					if ( button.currState == 'fully_pressed' && button.prevState != 'fully_pressed' ) {
    						if ( button.pressSound ) button.pressSound.play();
						    button.action();
    					}
    					if ( button.currState == 'recovering' && button.prevState != 'recovering' ) {
    						if ( button.releaseSound ) button.releaseSound.play();
    					}

					    // preserve prevState, clear currState
					    // FingerInputSystem will update currState
					    button.prevState = button.currState;
					    button.currState = 'resting';
    				} );
			    }
		    }

		    ButtonSystem.queries = {
			    buttons: {
				    components: [ Button ]
			    }
		    };

    	    class Pressable extends TagComponent { }
		    class FingerInputSystem extends System {
                init( attributes ) {
    				this.hands = attributes.hands;
    			}

			    execute( delta/*, time*/ ) {
                    this.queries.pressable.results.forEach( entity => {
    					const button = entity.getMutableComponent( Button );
	    				const object = entity.getComponent( Object3D ).object;
		    			const pressingDistances = [];
			    		this.hands.forEach( hand => {
						    if ( hand && hand.intersectBoxObject( object ) ) {
    							const pressingPosition = hand.getPointerPosition();
	    						pressingDistances.push( button.surfaceY - object.worldToLocal( pressingPosition ).y );
    						}
					    } );
					    if ( pressingDistances.length == 0 ) { // not pressed this frame
						    if ( object.position.y < button.restingY ) {
							    object.position.y += button.recoverySpeed * delta;
							    button.currState = 'recovering';
						    } 
                            else {
							    object.position.y = button.restingY;
							    button.currState = 'resting';
						    }
					    } 
                        else {
						    button.currState = 'pressed';
						    const pressingDistance = Math.max( pressingDistances );
						    if ( pressingDistance > 0 ) {
							    object.position.y -= pressingDistance;
						    }
						    if ( object.position.y <= button.restingY - button.fullPressDistance ) {
							    button.currState = 'fully_pressed';
							    object.position.y = button.restingY - button.fullPressDistance;
						    }
					    }
				    } );
    			}
    		}

		    FingerInputSystem.queries = {
			    pressable: {
				    components: [ Pressable ]
			    }
		    };

            class Rotating extends TagComponent { }
		    class RotatingSystem extends System {
    			execute( delta/*, time*/ ) {
    				this.queries.rotatingObjects.results.forEach( entity => {
    					const object = entity.getComponent( Object3D ).object;
	    				object.rotation.x += 0.4 * delta;
		    			object.rotation.y += 0.4 * delta;
    				} );
    			}
    		}

		    RotatingSystem.queries = {
			    rotatingObjects: {
				    components: [ Rotating ]
			    }
		    };

            class HandsInstructionText extends TagComponent { }
    		class InstructionSystem extends System {
    			init( attributes ) {
    				this.controllers = attributes.controllers;
    			}
    			execute( /*delta, time*/ ) {
    				let visible = false;
				    this.controllers.forEach( controller => {
    					if ( controller.visible ) {
    						visible = true;
    					}
    				} );
    				this.queries.instructionTexts.results.forEach( entity => {
    					const object = entity.getComponent( Object3D ).object;
	    				object.visible = visible;
    				} );
    			}
    		}

		    InstructionSystem.queries = {
			    instructionTexts: {
				    components: [ HandsInstructionText ]
			    }
		    };

		    class OffsetFromCamera extends Component { }
    		OffsetFromCamera.schema = {
			    x: { type: Types.Number, default: 0 },
			    y: { type: Types.Number, default: 0 },
			    z: { type: Types.Number, default: 0 },
		    };

		    class NeedCalibration extends TagComponent { }
    		class CalibrationSystem extends System {
    			init( attributes ) {
    				this.camera = attributes.camera;
				    this.renderer = attributes.renderer;
    			}
    			execute( /*delta, time*/ ) {
    				this.queries.needCalibration.results.forEach( entity => {
    					if ( this.renderer.xr.getSession() ) {
    						const offset = entity.getComponent( OffsetFromCamera );
	    					const object = entity.getComponent( Object3D ).object;
		    				const xrCamera = this.renderer.xr.getCamera();
			    			object.position.x = xrCamera.position.x + offset.x;
				    		object.position.y = xrCamera.position.y + offset.y;
					    	object.position.z = xrCamera.position.z + offset.z;
						    entity.removeComponent( NeedCalibration );
    					}
    				} );
    			}
    		}

		    CalibrationSystem.queries = {
			    needCalibration: {
				    components: [ NeedCalibration ]
			    }
		    };
		
            function makeButtonMesh( x, y, z, color ) {
                const geometry = new THREE.BoxGeometry( x, y, z );
                const material = new THREE.MeshPhongMaterial( { color: color } );
                const buttonMesh = new THREE.Mesh( geometry, material );
                buttonMesh.castShadow = true;
                buttonMesh.receiveShadow = true;
                return buttonMesh;
            }

            const world = new World();
            const clock = new THREE.Clock();
            let camera, scene, renderer, sphere, loader, manager;

            init();

			function init() {

                const container = document.getElementById( 'container' );
                
                // 1. 
                scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x101010 );

				const light = new THREE.AmbientLight( 0xffffff, 3 );
				scene.add( light );				            

                // 2.
				// Create the panoramic sphere geometery
				const panoSphereGeo = new THREE.SphereGeometry( 6, 256, 256 );

				// Create the panoramic sphere material
				const panoSphereMat = new THREE.MeshStandardMaterial( {
					side: THREE.BackSide,
					displacementScale: - 4.0
				} );

				// Create the panoramic sphere mesh
				sphere = new THREE.Mesh( panoSphereGeo, panoSphereMat );

				// Load and assign the texture and depth map
				manager = new THREE.LoadingManager();
				loader = new THREE.TextureLoader( manager );

				loader.load( './kandao3.jpg', function ( texture ) {

					texture.colorSpace = THREE.SRGBColorSpace;
					texture.minFilter = THREE.NearestFilter;
					texture.generateMipmaps = false;                    
					sphere.material.map = texture;

				} );

                // On load complete add the panoramic sphere to the scene
				manager.onLoad = function () {
                    scene.add( sphere );
                };
                
                // 3.
                camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 2000 );
                camera.position.set( 0, 0, 0 );
				scene.add( camera ); 

                // 4.
                renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.xr.enabled = true;
				renderer.xr.setReferenceSpaceType( 'local' );
				container.appendChild( renderer.domElement );

                const sessionInit = {
				    requiredFeatures: [ 'hand-tracking' ]
			    };

				document.body.appendChild( VRButton.createButton( renderer, sessionInit ) );

                // controllers
			    const controller1 = renderer.xr.getController( 0 );
			    scene.add( controller1 );

			    const controller2 = renderer.xr.getController( 1 );
			    scene.add( controller2 );

			    const controllerModelFactory = new XRControllerModelFactory();

                // Hand 1
			    const controllerGrip1 = renderer.xr.getControllerGrip( 0 );
			    controllerGrip1.add( controllerModelFactory.createControllerModel( controllerGrip1 ) );
			    scene.add( controllerGrip1 );

			    const hand1 = renderer.xr.getHand( 0 );
			    const handModel1 = new OculusHandModel( hand1 );
			    hand1.add( handModel1 );
			    scene.add( hand1 );

			    // Hand 2
			    const controllerGrip2 = renderer.xr.getControllerGrip( 1 );
			    controllerGrip2.add( controllerModelFactory.createControllerModel( controllerGrip2 ) );
			    scene.add( controllerGrip2 );

			    const hand2 = renderer.xr.getHand( 1 );
			    const handModel2 = new OculusHandModel( hand2 );
			    hand2.add( handModel2 );
			    scene.add( hand2 );

                // Buttons
                
                const consoleGeometry = new THREE.BoxGeometry( 0.5, 0.12, 0.15 );
                const consoleMaterial = new THREE.MeshPhongMaterial( { color: 0x595959 } );
                const consoleMesh = new THREE.Mesh( consoleGeometry, consoleMaterial );
                consoleMesh.position.set( 0, -0.25, - 0.3 );
				consoleMesh.rotation.x = 0.8;
                consoleMesh.castShadow = true;
                consoleMesh.receiveShadow = true;
                scene.add( consoleMesh );

                const orangeButton = makeButtonMesh( 0.08, 0.1, 0.08, 0xffd3b5 );
			    orangeButton.position.set( - 0.15, 0.04, 0 );
			    consoleMesh.add( orangeButton );

                const pinkButton = makeButtonMesh( 0.08, 0.1, 0.08, 0xe84a5f );
                pinkButton.position.set( - 0.05, 0.04, 0 );
                consoleMesh.add( pinkButton );

                const resetButton = makeButtonMesh( 0.08, 0.1, 0.08, 0x355c7d );
                const resetButtonText = createText( 'reset', 0.03 );
                resetButton.add( resetButtonText );
                resetButtonText.rotation.x = - Math.PI / 2;
                resetButtonText.position.set( 0, 0.051, 0 );
                resetButton.position.set( 0.05, 0.04, 0 );
                consoleMesh.add( resetButton );

                const exitButton = makeButtonMesh( 0.08, 0.1, 0.08, 0xff0000 );
                const exitButtonText = createText( 'exit', 0.03 );
                exitButton.add( exitButtonText );
                exitButtonText.rotation.x = - Math.PI / 2;
                exitButtonText.position.set( 0, 0.051, 0 );
                exitButton.position.set( 0.15, 0.04, 0 );
                consoleMesh.add( exitButton );

                const tkGeometry = new THREE.TorusKnotGeometry( 0.5, 0.2, 200, 32 );
                const tkMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff } );
                tkMaterial.metalness = 0.8;
                const torusKnot = new THREE.Mesh( tkGeometry, tkMaterial );
                torusKnot.position.set( 0, 1, - 5 );
                scene.add( torusKnot );

                world
                    .registerComponent( Object3D )
                    .registerComponent( Button )
                    .registerComponent( Pressable )
                    .registerComponent( Rotating )
                    .registerComponent( HandsInstructionText )
                    .registerComponent( OffsetFromCamera )
                    .registerComponent( NeedCalibration );

			    world
                    .registerSystem( RotatingSystem )
                    .registerSystem( InstructionSystem, { controllers: [ controllerGrip1, controllerGrip2 ] } )
                    .registerSystem( CalibrationSystem, { renderer: renderer, camera: camera } )
                    .registerSystem( ButtonSystem, { renderer: renderer, camera: camera } )
                    .registerSystem( FingerInputSystem, { hands: [ handModel1, handModel2 ] } );

                const csEntity = world.createEntity();
			    csEntity.addComponent( OffsetFromCamera, { x: 0, y: - 0.4, z: - 0.3 } );
			    csEntity.addComponent( NeedCalibration );
			    csEntity.addComponent( Object3D, { object: consoleMesh } );

			    const obEntity = world.createEntity();
			    obEntity.addComponent( Pressable );
			    obEntity.addComponent( Object3D, { object: orangeButton } );
                const obAction = function () {
                    console.log("Action on Orange Button");
                    torusKnot.material.color.setHex( 0xffd3b5 );
                    loader.load( './kandao3_depthmap.jpg', function ( texture ) {
                        texture.colorSpace = THREE.SRGBColorSpace;
                        texture.minFilter = THREE.NearestFilter;
                        texture.generateMipmaps = false;                    
                        sphere.material.map = texture;
                        sphere.material.needsUpdate = true;
                    } );
                };
                // On load complete add the panoramic sphere to the scene
				//manager.onLoad = function () {
                  //  scene.add( sphere );
                //};
                obEntity.addComponent( Button, { action: obAction, surfaceY: 0.05, fullPressDistance: 0.02 } );

                const tkEntity = world.createEntity();
			    tkEntity.addComponent( Rotating );
			    tkEntity.addComponent( Object3D, { object: torusKnot } );

				const loader2 = new GLTFLoader().setPath( './' );
				loader2.load( 'Adventurer.gltf', async function ( gltf ) {
					
							const model = gltf.scene;
							model.scale.set(0.5, 0.5, 0.5);
							model.position.set(0.5,0,-1); 
							// wait until the model can be added to the scene without blocking due to shader compilation
							await renderer.compileAsync( model, camera, scene );
							scene.add( model );			
				} );

				// 5.
				window.addEventListener( 'resize', onWindowResize );

            }
            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            function animate() {

                const delta = clock.getDelta();
                const elapsedTime = clock.elapsedTime;
                renderer.xr.updateCamera( camera );
                world.execute( delta, elapsedTime );
                renderer.render( scene, camera );

            }
        </script>
    </body>
</html>

